# Σχεδιασμός Ενσωματωμένων Συστημάτων

### Αναφορά 2ης Άσκησης | Βάρδια 1 Ομάδα 2

|||
|--------|------|
| Γρηγόρης Μαντάος |03113171|
| Γαβαλάς Νικόλαος |03113121|



## Άσκηση 1

```bash
make ex1
./ex1
```

Η ιδέα είναι η εξής: διαβάζουμε input από το χρήστη μέχρι να βρούμε newline, και σώζουμε στον input buffer. Μόλις πάρουμε την είσοδο, βάζουμε έναν null terminator στον 33ο χαρακτήρα για να περιορίσουμε το string στους 32 χαρακτήρες.

Αφού διαβαστεί η είσοδος, καλείτε η συνάρτηση `transform` με όρισμα στον `r0` την διεύθυνση του string που θέλουμε να μεταμορφώσουμε στη μνήμη. Η συνάρτηση αυτή εφαρμόζει in-place τους μετασχιματισμούς που περιγράφει η εκφώνηση με if/else ελέχγους με χρήση conditional branches της ARM assembly. 

## Άσκηση 2

```bash
make ex2
./ex2
```

Το input καταναλώνεται από το stdin ακριβώς όπως και στην πρώτη άσκηση.

Ύστερα ελέγχουμε αν το string έχει μήκος 1 και αποτελείται από τον χαρακτήρα 'q' ή 'Q', οπότε και κάνουμε exit. Αν δεν είναι 'q' ή 'Q', καλούμε την συνάρτηση parse. Η συνάρτηση αυτή πάει στο string και μετράει για κάθε χαρακτήρα του πόσες άλλες φορές αυτός εμφανίζεται, και ύστερα σώζει τον χαρακτήρα αυτόν σε έναν buffer 'key', και το πλήθος των φορών που εμφανίζεται σε έναν buffer 'value'.

Τέλος για την εκτύπωση των αποτελεσμάτων, κάνουμε ένα loop πάνω στους δύο αυτούς buffers και με τη βοήθεια της sprintf, τους μορφοποιούμε κατάλληλα και τους τυπώνουμε με το syscall 'write' στο αρχείο 'count.txt'. Η διαδικασία είναι επαναληπτική.

## Άσκηση 3

```bash
make ex3
./ex3 in_file
```

Για κάποιο λόγο, ακόμα και ακολουθόντας ακριβώς τις οδηγείες για την αντικατάσταση των εντολών που ζητούνταν με χρήση του keyword `extern`, η C εξακολουθούσε να χρησιμοποιεί τις built-in εντολές. Οπότε όπως θα δείτε και στα source files, χρησιμοποιήσαμε νέα ονόματα προσθέτοντας underscore στην αρχή των original ονομάτων.

Η υλοποίηση των εντολών ύστερα είναι πολύ straight-forward, χρησιμοποιώντας το παρακάτω σχήμα υλοποίησης στο αρχείο assembly:

```arm
.align		4

.global		_strlen
.type		_strlen, %function

/*
	r0:	input string
*/
_strlen:
	push	{r1-r7, lr}

	...

	pop	{r1-r7, pc}
```

Για επαλήθευση γράψαμε το script `ex3_tests.sh`, το οποίο εκτελεί τον κώδικά μας και τον original κώδικα που μας δώθηκε και συγκρίνει τα output αρχεία με χρήση της `md5sum`.

Όπου παίρνουμε το παρακάτω output:

```bash
Running for input_first
d03c8722d56e6092f48a03c0ef9f4ea9  t1_concat_out
d03c8722d56e6092f48a03c0ef9f4ea9  t1_default_concat_out
2e897e5e5cea8a51e88ce6366130506b  t1_len_out
2e897e5e5cea8a51e88ce6366130506b  t1_default_len_out
2ded91fc705f7017440019731a9ccd00  t1_sorted_out
2ded91fc705f7017440019731a9ccd00  t1_default_sorted_out
Running for input_sec
b17ac76e9e4c4aaef9bd57ea9c252f08  t2_concat_out
b17ac76e9e4c4aaef9bd57ea9c252f08  t2_default_concat_out
3d3a3debdc7cedbb48a4e647c2cae381  t2_len_out
3d3a3debdc7cedbb48a4e647c2cae381  t2_default_len_out
cb1878151ba0caa955f3050c1d458793  t2_sorted_out
cb1878151ba0caa955f3050c1d458793  t2_default_sorted_out
```




